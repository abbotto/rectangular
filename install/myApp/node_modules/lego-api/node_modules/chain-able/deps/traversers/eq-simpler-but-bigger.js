const traverse = require('../traverse')
const {
  isReal,
  toS,
  isFunction,
  isRegExp,
  isObj,
  isArguments,
  isDate,
} = require('../is')

function sameKeysLength(x, y) {
  return Object.keys(x).length === Object.keys(y).length
}

module.exports = function(a, b, loose) {
  if (loose === void 0) loose = false

  var equal = true
  var node = b

  traverse(a).forEach(function(y) {
    var notEqual = function() {
      equal = false
      //this.stop();
      return undefined
    }

    //if (node === undefined || node === null) return notEqual();

    if (!this.isRoot) {
      /*
            if (!Object.hasOwnProperty.call(node, this.key)) {
                return notEqual();
            }
        */
      if (typeof node !== 'object') {
        return notEqual()
      }
      node = node[this.key]
    }

    var x = node

    this.post(function() {
      node = x
    })

    if (this.circular) {
      if (traverse(b).get(this.circular.path) !== x) {
        notEqual()
      }
    }
    else if (typeof x !== typeof y) {
      if (loose === true && x == y) {
      }
      else {
        notEqual()
      }
    }
    else if (!isReal(x) && !isReal(y)) {
      if (x !== y) {
        notEqual()
      }
    }
    else if (x.__proto__ !== y.__proto__) {
      // @TODO isPrototypeOf...
      notEqual()
    }
    else if (x === y) {
      // nop
    }
    else if (isFunction(x)) {
      if (isRegExp(x)) {
        // both regexps on account of the __proto__ check
        if (x.toString() != y.toString()) {
          notEqual()
        }
      }
      else if (x !== y) {
        notEqual()
      }
    }
    else if (isObj(x)) {
      if (isArguments(x) || isArguments(y)) {
        if (toS(x) !== toS(y)) {
          notEqual()
        }
      }
      else if (toS(y) === '[object RegExp]' || toS(x) === '[object RegExp]') {
        if (!x || !y || x.toString() !== y.toString()) {
          notEqual()
        }
      }
      else if (isDate(x) || isDate(y)) {
        if (!isDate(x) || !isDate(y) || x.getTime() !== y.getTime()) {
          notEqual()
        }
      }
      else {
        if (!sameKeysLength(x, y)) {
          return notEqual()
        }
        var kx = Object.keys(x)
        for (var i = 0; i < kx.length; i++) {
          var k = kx[i]
          if (!Object.hasOwnProperty.call(y, k)) {
            notEqual()
          }
        }
      }
    }
  })

  return equal
}
